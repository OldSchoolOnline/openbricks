From 3154d8a6b3e92f727f8d4083c04148d1e8d85eec Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 5 Nov 2017 13:04:39 +0100
Subject: [PATCH 07/13] VideoPlayer: add DRM PRIME decoder

---
 .../VideoPlayer/DVDCodecs/Video/CMakeLists.txt     |   5 +
 .../cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.cpp | 217 +++++++++++++++++++++
 xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h  |  76 ++++++++
 3 files changed, 298 insertions(+)
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.cpp
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
index f4f5b07ad2..8d4f0d2035 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
@@ -56,4 +56,9 @@ if(CORE_SYSTEM_NAME STREQUAL android)
   list(APPEND HEADERS DVDVideoCodecAndroidMediaCodec.h)
 endif()
 
+if(CORE_PLATFORM_NAME STREQUAL gbm)
+  list(APPEND SOURCES DRMPRIME.cpp)
+  list(APPEND HEADERS DRMPRIME.h)
+endif()
+
 core_add_library(dvdvideocodecs)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.cpp
new file mode 100644
index 0000000000..4289079d40
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.cpp
@@ -0,0 +1,217 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DRMPRIME.h"
+
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "cores/VideoPlayer/Interface/Addon/TimingConstants.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "ServiceBroker.h"
+
+using namespace DRMPRIME;
+
+//------------------------------------------------------------------------------
+// Video Buffers
+//------------------------------------------------------------------------------
+
+CVideoBufferDRMPRIME::CVideoBufferDRMPRIME(IVideoBufferPool& pool, int id)
+  : CVideoBuffer(id)
+{
+  m_pFrame = av_frame_alloc();
+}
+
+CVideoBufferDRMPRIME::~CVideoBufferDRMPRIME()
+{
+  Unref(); // probably not needed
+  av_frame_free(&m_pFrame);
+}
+
+void CVideoBufferDRMPRIME::SetRef(AVFrame* frame)
+{
+  Unref(); // probably not needed
+  av_frame_ref(m_pFrame, frame);
+}
+
+void CVideoBufferDRMPRIME::Unref()
+{
+  av_frame_unref(m_pFrame);
+}
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+class DRMPRIME::CVideoBufferPoolDRMPRIME : public IVideoBufferPool
+{
+public:
+  virtual ~CVideoBufferPoolDRMPRIME();
+  virtual void Return(int id) override;
+  virtual CVideoBuffer* Get() override;
+
+protected:
+  CCriticalSection m_critSection;
+  std::vector<CVideoBufferDRMPRIME*> m_all;
+  std::deque<int> m_used;
+  std::deque<int> m_free;
+};
+
+CVideoBufferPoolDRMPRIME::~CVideoBufferPoolDRMPRIME()
+{
+  for (auto buf : m_all)
+  {
+    delete buf;
+  }
+}
+
+CVideoBuffer* CVideoBufferPoolDRMPRIME::Get()
+{
+  CSingleLock lock(m_critSection);
+
+  CVideoBufferDRMPRIME* buf = nullptr;
+  if (!m_free.empty())
+  {
+    int idx = m_free.front();
+    m_free.pop_front();
+    m_used.push_back(idx);
+    buf = m_all[idx];
+  }
+  else
+  {
+    int id = m_all.size();
+    buf = new CVideoBufferDRMPRIME(*this, id);
+    m_all.push_back(buf);
+    m_used.push_back(id);
+  }
+
+  buf->Acquire(GetPtr());
+  return buf;
+}
+
+void CVideoBufferPoolDRMPRIME::Return(int id)
+{
+  CSingleLock lock(m_critSection);
+
+  m_all[id]->Unref();
+  auto it = m_used.begin();
+  while (it != m_used.end())
+  {
+    if (*it == id)
+    {
+      m_used.erase(it);
+      break;
+    }
+    else
+      ++it;
+  }
+  m_free.push_back(id);
+}
+
+//------------------------------------------------------------------------------
+// main class
+//------------------------------------------------------------------------------
+
+IHardwareDecoder* CDecoder::Create(CDVDStreamInfo& hint, CProcessInfo& processInfo, const enum AVPixelFormat fmt)
+{
+  if (fmt == AV_PIX_FMT_DRM_PRIME /*&& CServiceBroker::GetSettings().GetBool(CSettings::SETTING_VIDEOPLAYER_USEDRMPRIME)*/)
+    return new DRMPRIME::CDecoder(processInfo);
+
+  return nullptr;
+}
+
+bool CDecoder::Register()
+{
+  CDVDFactoryCodec::RegisterHWAccel("drm_prime", CDecoder::Create);
+  return true;
+}
+
+CDecoder::CDecoder(CProcessInfo& processInfo)
+  : m_processInfo(processInfo)
+{
+  m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIME>();
+}
+
+CDecoder::~CDecoder()
+{
+  if (m_renderBuffer)
+    m_renderBuffer->Release();
+}
+
+bool CDecoder::Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum AVPixelFormat fmt)
+{
+  //if (!CServiceBroker::GetSettings().GetBool(CSettings::SETTING_VIDEOPLAYER_USEDRMPRIME))
+  //  return false;
+
+  m_processInfo.SetVideoDeintMethod("none");
+
+  std::list<EINTERLACEMETHOD> deintMethods;
+  deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_NONE);
+  m_processInfo.UpdateDeinterlacingMethods(deintMethods);
+
+  return true;
+}
+
+CDVDVideoCodec::VCReturn CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
+{
+  CDVDVideoCodec::VCReturn status = Check(avctx);
+  if (status)
+    return status;
+
+  if (frame)
+  {
+    if (m_renderBuffer)
+      m_renderBuffer->Release();
+    m_renderBuffer = dynamic_cast<CVideoBufferDRMPRIME*>(m_videoBufferPool->Get());
+    m_renderBuffer->SetRef(frame);
+    return CDVDVideoCodec::VC_PICTURE;
+  }
+  else
+    return CDVDVideoCodec::VC_BUFFER;
+}
+
+bool CDecoder::GetPicture(AVCodecContext* avctx, VideoPicture* picture)
+{
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "CDecoderDRMPRIME::%s - buffer:%p width:%u height:%u pts:%" PRId64, __FUNCTION__, m_renderBuffer, m_renderBuffer->GetWidth(), m_renderBuffer->GetHeight(), m_renderBuffer->GetPTS());
+
+  ((ICallbackHWAccel*)avctx->opaque)->GetPictureCommon(picture);
+
+  if (picture->videoBuffer)
+    picture->videoBuffer->Release();
+
+  picture->videoBuffer = m_renderBuffer;
+  picture->videoBuffer->Acquire();
+
+  picture->dts = DVD_NOPTS_VALUE;
+  picture->pts = (double)m_renderBuffer->GetPTS() * DVD_TIME_BASE / AV_TIME_BASE;
+
+  return true;
+}
+
+CDVDVideoCodec::VCReturn CDecoder::Check(AVCodecContext* avctx)
+{
+  return CDVDVideoCodec::VC_NONE;
+}
+
+unsigned CDecoder::GetAllowedReferences()
+{
+  return 4;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h
new file mode 100644
index 0000000000..b34c4dae6f
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h
@@ -0,0 +1,76 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/Process/VideoBuffer.h"
+
+extern "C" {
+#include "libavutil/frame.h"
+#include "libavutil/hwcontext_drm.h"
+}
+
+class CProcessInfo;
+
+namespace DRMPRIME
+{
+class CVideoBufferDRMPRIME;
+class CVideoBufferPoolDRMPRIME;
+
+class CVideoBufferDRMPRIME
+  : public CVideoBuffer
+{
+public:
+  CVideoBufferDRMPRIME(IVideoBufferPool& pool, int id);
+  virtual ~CVideoBufferDRMPRIME();
+  void SetRef(AVFrame* frame);
+  void Unref();
+
+  AVDRMFrameDescriptor* GetDescriptor() const { return (AVDRMFrameDescriptor*)m_pFrame->data[0]; }
+  uint32_t GetWidth() const { return m_pFrame->width; }
+  uint32_t GetHeight() const { return m_pFrame->height; }
+  int64_t GetPTS() const { return m_pFrame->pts; }
+protected:
+  AVFrame* m_pFrame = nullptr;
+};
+
+class CDecoder
+  : public IHardwareDecoder
+{
+public:
+  CDecoder(CProcessInfo& processInfo);
+  virtual ~CDecoder();
+  static IHardwareDecoder* Create(CDVDStreamInfo& hint, CProcessInfo& processInfo, const enum AVPixelFormat fmt);
+  static bool Register();
+  bool Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum AVPixelFormat fmt) override;
+  CDVDVideoCodec::VCReturn Decode(AVCodecContext* avctx, AVFrame* frame) override;
+  bool GetPicture(AVCodecContext* avctx, VideoPicture* picture) override;
+  CDVDVideoCodec::VCReturn Check(AVCodecContext* avctx) override;
+  unsigned GetAllowedReferences() override;
+  const std::string Name() override { return "drm_prime"; }
+
+protected:
+  CProcessInfo& m_processInfo;
+  CVideoBufferDRMPRIME* m_renderBuffer = nullptr;
+  std::shared_ptr<CVideoBufferPoolDRMPRIME> m_videoBufferPool;
+};
+
+}
-- 
2.11.0

