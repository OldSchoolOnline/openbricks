From 10545fa3480541a2dcceaa390313687a782e0c2f Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 5 Nov 2017 13:04:39 +0100
Subject: [PATCH 08/13] VideoPlayer: add DRM PRIME renderer

---
 .../VideoRenderers/HwDecRender/CMakeLists.txt      |   5 +
 .../HwDecRender/RendererDRMPRIME.cpp               | 186 +++++++++++++++++++++
 .../VideoRenderers/HwDecRender/RendererDRMPRIME.h  |  71 ++++++++
 3 files changed, 262 insertions(+)
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
index 7148da2b58..91627fb0b8 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
@@ -54,6 +54,11 @@ if(CORE_SYSTEM_NAME STREQUAL android)
                       RendererMediaCodecSurface.h)
 endif()
 
+if(CORE_PLATFORM_NAME STREQUAL gbm)
+  list(APPEND SOURCES RendererDRMPRIME.cpp)
+  list(APPEND HEADERS RendererDRMPRIME.h)
+endif()
+
 # we might want to build on linux systems
 # with ENABLE_VDPAU=OFF and ENABLE_VAAPI=OFF
 if(SOURCES)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
new file mode 100644
index 0000000000..bcc56fbe21
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -0,0 +1,186 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererDRMPRIME.h"
+
+#include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/MediaSettings.h"
+#include "utils/log.h"
+#include "windowing/WindowingFactory.h"
+
+using namespace DRMPRIME;
+
+CRendererDRMPRIME::CRendererDRMPRIME()
+{
+  CLog::Log(LOGINFO, "CRendererDRMPRIME::%s", __FUNCTION__);
+}
+
+CRendererDRMPRIME::~CRendererDRMPRIME()
+{
+  CLog::Log(LOGINFO, "CRendererDRMPRIME::%s", __FUNCTION__);
+
+  Reset();
+}
+
+CBaseRenderer* CRendererDRMPRIME::Create(CVideoBuffer *buffer)
+{
+  if (buffer && dynamic_cast<CVideoBufferDRMPRIME*>(buffer))
+    return new CRendererDRMPRIME();
+
+  return nullptr;
+}
+
+bool CRendererDRMPRIME::Register()
+{
+  VIDEOPLAYER::CRendererFactory::RegisterRenderer("drm_prime", CRendererDRMPRIME::Create);
+  return true;
+}
+
+bool CRendererDRMPRIME::Configure(const VideoPicture& picture, float fps, unsigned flags, unsigned int orientation)
+{
+  m_format = picture.videoBuffer->GetFormat();
+  m_sourceWidth = picture.iWidth;
+  m_sourceHeight = picture.iHeight;
+  m_renderOrientation = orientation;
+
+  // Save the flags.
+  m_iFlags = flags;
+
+  // Calculate the input frame aspect ratio.
+  CalculateFrameAspectRatio(picture.iDisplayWidth, picture.iDisplayHeight);
+  SetViewMode(m_videoSettings.m_ViewMode);
+  ManageRenderArea();
+
+  Reset();
+
+  m_bConfigured = true;
+  return true;
+}
+
+void CRendererDRMPRIME::AddVideoPicture(const VideoPicture& picture, int index, double currentClock)
+{
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "CRendererDRMPRIME::%s - index:%d buffer:%p", __FUNCTION__, index, picture.videoBuffer);
+
+  ReleaseBuffer(index); // probably not needed
+
+  BUFFER& buf = m_buffers[index];
+  buf.videoBuffer = picture.videoBuffer;
+  buf.videoBuffer->Acquire();
+}
+
+void CRendererDRMPRIME::Reset()
+{
+  for (int i = 0; i < m_numRenderBuffers; i++)
+    ReleaseBuffer(i);
+
+  m_iLastRenderBuffer = -1;
+}
+
+void CRendererDRMPRIME::ReleaseBuffer(int index)
+{
+  BUFFER& buf = m_buffers[index];
+  if (buf.videoBuffer)
+  {
+    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+      CLog::Log(LOGDEBUG, "CRendererDRMPRIME::%s - index:%d buffer:%p", __FUNCTION__, index, buf.videoBuffer);
+
+    CVideoBufferDRMPRIME* buffer = dynamic_cast<CVideoBufferDRMPRIME*>(buf.videoBuffer);
+    if (buffer)
+      buffer->Release();
+    buf.videoBuffer = nullptr;
+  }
+}
+
+bool CRendererDRMPRIME::NeedBuffer(int index)
+{
+  return m_iLastRenderBuffer == index;
+}
+
+CRenderInfo CRendererDRMPRIME::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.max_buffer_size = m_numRenderBuffers;
+  info.optimal_buffer_size = m_numRenderBuffers;
+  info.opaque_pointer = (void*)this;
+  return info;
+}
+
+void CRendererDRMPRIME::Update()
+{
+  if (!m_bConfigured)
+    return;
+
+  ManageRenderArea();
+}
+
+void CRendererDRMPRIME::RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha)
+{
+  if (m_iLastRenderBuffer == index)
+    return;
+
+  CVideoBufferDRMPRIME* buffer = dynamic_cast<CVideoBufferDRMPRIME*>(m_buffers[index].videoBuffer);
+  if (buffer)
+  {
+    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+      CLog::Log(LOGDEBUG, "CRendererDRMPRIME::%s - index:%d buffer:%p pts:%" PRId64, __FUNCTION__, index, buffer, buffer->GetPTS());
+
+    SetVideoPlane(buffer);
+  }
+
+  m_iLastRenderBuffer = index;
+}
+
+bool CRendererDRMPRIME::RenderCapture(CRenderCapture* capture)
+{
+  capture->BeginRender();
+  capture->EndRender();
+  return true;
+}
+
+bool CRendererDRMPRIME::ConfigChanged(const VideoPicture& picture)
+{
+  if (picture.videoBuffer->GetFormat() != m_format)
+    return true;
+
+  return false;
+}
+
+bool CRendererDRMPRIME::Supports(ERENDERFEATURE feature)
+{
+  if (feature == RENDERFEATURE_ZOOM ||
+      feature == RENDERFEATURE_STRETCH ||
+      feature == RENDERFEATURE_PIXEL_RATIO)
+    return true;
+
+  return false;
+}
+
+bool CRendererDRMPRIME::Supports(ESCALINGMETHOD method)
+{
+  return false;
+}
+
+void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
+{
+  // TODO: implement
+}
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h
new file mode 100644
index 0000000000..4f058949aa
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h
@@ -0,0 +1,71 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DRMPRIME.h"
+#include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+
+class CRendererDRMPRIME
+  : public CBaseRenderer
+{
+public:
+  CRendererDRMPRIME();
+  virtual ~CRendererDRMPRIME();
+
+  // Registration
+  static CBaseRenderer* Create(CVideoBuffer* buffer);
+  static bool Register();
+
+  // Player functions
+  bool Configure(const VideoPicture& picture, float fps, unsigned flags, unsigned int orientation) override;
+  bool IsConfigured() override { return m_bConfigured; };
+  void AddVideoPicture(const VideoPicture& picture, int index, double currentClock) override;
+  void UnInit() override {};
+  void Reset() override;
+  void ReleaseBuffer(int idx) override;
+  bool NeedBuffer(int idx) override;
+  bool IsGuiLayer() override { return false; };
+  CRenderInfo GetRenderInfo() override;
+  void Update() override;
+  void RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha) override;
+  bool RenderCapture(CRenderCapture* capture) override;
+  bool ConfigChanged(const VideoPicture& picture) override;
+
+  // Feature support
+  bool SupportsMultiPassRendering() override { return false; };
+  bool Supports(ERENDERFEATURE feature) override;
+  bool Supports(ESCALINGMETHOD method) override;
+
+private:
+  void SetVideoPlane(DRMPRIME::CVideoBufferDRMPRIME* buffer);
+
+  bool m_bConfigured = false;
+  int m_iLastRenderBuffer = -1;
+  static const int m_numRenderBuffers = 4;
+
+  struct BUFFER
+  {
+    BUFFER() : videoBuffer(nullptr) {};
+    CVideoBuffer* videoBuffer;
+  } m_buffers[m_numRenderBuffers];
+};
-- 
2.11.0

