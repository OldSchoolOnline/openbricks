diff --git a/xbmc/windowing/gbm/CMakeLists.txt b/xbmc/windowing/gbm/CMakeLists.txt
index 95b4bf9ce782..53de4bac919c 100644
--- a/xbmc/windowing/gbm/CMakeLists.txt
+++ b/xbmc/windowing/gbm/CMakeLists.txt
@@ -3,15 +3,16 @@ set(SOURCES OptionalsReg.cpp
             WinSystemGbm.cpp
             GBMUtils.cpp
             DRMUtils.cpp
-            DRMLegacy.cpp)
-
+            DRMLegacy.cpp
+            DRMAtomic.cpp)
 
 set(HEADERS OptionalsReg.h
             GLContextEGL.h
             WinSystemGbm.h
             GBMUtils.h
             DRMUtils.h
-            DRMLegacy.h)
+            DRMLegacy.h
+            DRMAtomic.h)
 
 if(OPENGLES_FOUND)
   list(APPEND SOURCES WinSystemGbmGLESContext.cpp)
diff --git a/xbmc/windowing/gbm/DRMAtomic.cpp b/xbmc/windowing/gbm/DRMAtomic.cpp
new file mode 100644
index 000000000000..0595a2105e0a
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.cpp
@@ -0,0 +1,231 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <errno.h>
+#include <drm_mode.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+#include "DRMAtomic.h"
+#include "WinSystemGbmGLESContext.h"
+
+bool CDRMAtomic::AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct connector *obj = m_connector;
+  int prop_id = 0;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no connector property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct crtc *obj = m_crtc;
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no crtc property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value)
+{
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no plane property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj->plane->plane_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags)
+{
+  uint32_t blob_id;
+
+  if (flags & DRM_MODE_ATOMIC_ALLOW_MODESET)
+  {
+    if (!AddConnectorProperty(m_req, m_connector->connector->connector_id, "CRTC_ID", m_crtc->crtc->crtc_id))
+    {
+      return false;
+    }
+
+    if (drmModeCreatePropertyBlob(m_fd, m_mode, sizeof(*m_mode), &blob_id) != 0)
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(m_req, m_crtc->crtc->crtc_id, "MODE_ID", blob_id))
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(m_req, m_crtc->crtc->crtc_id, "ACTIVE", 1))
+    {
+      return false;
+    }
+  }
+
+  AddPlaneProperty(m_req, m_primary_plane, "FB_ID", fb_id);
+  AddPlaneProperty(m_req, m_primary_plane, "CRTC_ID", m_crtc->crtc->crtc_id);
+  AddPlaneProperty(m_req, m_primary_plane, "SRC_X", 0);
+  AddPlaneProperty(m_req, m_primary_plane, "SRC_Y", 0);
+  AddPlaneProperty(m_req, m_primary_plane, "SRC_W", m_mode->hdisplay << 16);
+  AddPlaneProperty(m_req, m_primary_plane, "SRC_H", m_mode->vdisplay << 16);
+  AddPlaneProperty(m_req, m_primary_plane, "CRTC_X", 0);
+  AddPlaneProperty(m_req, m_primary_plane, "CRTC_Y", 0);
+  AddPlaneProperty(m_req, m_primary_plane, "CRTC_W", m_mode->hdisplay);
+  AddPlaneProperty(m_req, m_primary_plane, "CRTC_H", m_mode->vdisplay);
+
+  auto ret = drmModeAtomicCommit(m_fd, m_req, flags, nullptr);
+  if (ret)
+  {
+    return false;
+  }
+
+  drmModeAtomicFree(m_req);
+
+  m_req = drmModeAtomicAlloc();
+
+  return true;
+}
+
+void CDRMAtomic::FlipPage(struct gbm_bo *bo)
+{
+  uint32_t flags = 0;
+
+  if(m_need_modeset)
+  {
+    flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
+    m_need_modeset = false;
+  }
+
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(bo);
+  if (!drm_fb)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
+    return;
+  }
+
+  auto ret = DrmAtomicCommit(drm_fb->fb_id, flags);
+  if (!ret) {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to commit: %s", __FUNCTION__, strerror(errno));
+    return;
+  }
+}
+
+bool CDRMAtomic::InitDrm()
+{
+  if (!CDRMUtils::OpenDrm())
+  {
+    return false;
+  }
+
+  auto ret = drmSetClientCap(m_fd, DRM_CLIENT_CAP_ATOMIC, 1);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no atomic modesetting support: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
+  m_req = drmModeAtomicAlloc();
+
+  if (!CDRMUtils::InitDrm())
+  {
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "CDRMAtomic::%s - initialized atomic DRM", __FUNCTION__);
+  return true;
+}
+
+void CDRMAtomic::DestroyDrm()
+{
+  CDRMUtils::DestroyDrm();
+
+  drmModeAtomicFree(m_req);
+  m_req = nullptr;
+}
+
+bool CDRMAtomic::SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo)
+{
+  m_need_modeset = true;
+
+  return true;
+}
diff --git a/xbmc/windowing/gbm/DRMAtomic.h b/xbmc/windowing/gbm/DRMAtomic.h
new file mode 100644
index 000000000000..dd296c142c0d
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.h
@@ -0,0 +1,42 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "DRMUtils.h"
+
+class CDRMAtomic : public CDRMUtils
+{
+public:
+  CDRMAtomic() = default;
+  ~CDRMAtomic() { DestroyDrm(); };
+  virtual void FlipPage(struct gbm_bo *bo) override;
+  virtual bool SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo) override;
+  virtual bool InitDrm() override;
+  virtual void DestroyDrm() override;
+
+private:
+  bool AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  bool AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  bool AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value);
+  bool DrmAtomicCommit(int fb_id, int flags);
+
+  bool m_need_modeset;
+};
diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index dbf60f42f496..5b5c8867a216 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -155,6 +155,11 @@ void CDRMLegacy::FlipPage(struct gbm_bo *bo)
 
 bool CDRMLegacy::InitDrm()
 {
+  if (!CDRMUtils::OpenDrm())
+  {
+    return false;
+  }
+
   if (!CDRMUtils::InitDrm())
   {
     return false;
diff --git a/xbmc/windowing/gbm/DRMLegacy.h b/xbmc/windowing/gbm/DRMLegacy.h
index edc589775083..820676cdbf38 100644
--- a/xbmc/windowing/gbm/DRMLegacy.h
+++ b/xbmc/windowing/gbm/DRMLegacy.h
@@ -21,7 +21,6 @@
 #pragma once
 
 #include "DRMUtils.h"
-#include "GLContextEGL.h"
 
 class CDRMLegacy : public CDRMUtils
 {
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index 34ee89787b0b..c5ffb95c95c3 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -423,10 +423,8 @@ bool CDRMUtils::GetPlanes()
   return true;
 }
 
-int CDRMUtils::Open(const char* device)
+bool CDRMUtils::OpenDrm()
 {
-  int fd = -1;
-
   std::vector<const char*>modules =
   {
     "i915",
@@ -442,67 +440,85 @@ int CDRMUtils::Open(const char* device)
     "sun4i-drm",
   };
 
-  for (auto module : modules)
+  for(int i = 0; i < 10; ++i)
   {
-    fd = drmOpen(module, device);
-    if (fd >= 0)
+    std::string device = "/dev/dri/card";
+    device.append(std::to_string(i));
+
+    for (auto module : modules)
     {
-      CLog::Log(LOGDEBUG, "CDRMUtils::%s - opened device: %s using module: %s", __FUNCTION__, device, module);
-      break;
+      m_fd = drmOpen(module, device.c_str());
+      if (m_fd >= 0)
+      {
+        if(!GetResources())
+        {
+          continue;
+        }
+
+        if(!GetConnector())
+        {
+          continue;
+        }
+
+        drmModeFreeResources(m_drm_resources);
+        m_drm_resources = nullptr;
+
+        drmModeFreeConnector(m_connector->connector);
+        m_connector->connector = nullptr;
+
+        drmModeFreeObjectProperties(m_connector->props);
+        m_connector->props = nullptr;
+
+        drmModeFreeProperty(*m_connector->props_info);
+        *m_connector->props_info = nullptr;
+
+        CLog::Log(LOGDEBUG, "CDRMUtils::%s - opened device: %s using module: %s", __FUNCTION__, device.c_str(), module);
+        return true;
+      }
+
+      drmClose(m_fd);
+      m_fd = -1;
     }
   }
 
-  return fd;
+  return false;
 }
 
 bool CDRMUtils::InitDrm()
 {
-  for(int i = 0; i < 10; ++i)
+  if(m_fd >= 0)
   {
-    if (m_fd >= 0)
+    /* caps need to be set before allocating connectors, encoders, crtcs, and planes */
+    auto ret = drmSetClientCap(m_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+    if (ret)
     {
-      drmClose(m_fd);
+      CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
+      return false;
     }
 
-    std::string device = "/dev/dri/card";
-    device.append(std::to_string(i));
-    m_fd = CDRMUtils::Open(device.c_str());
-
-    if(m_fd >= 0)
+    if(!GetResources())
     {
-      if(!GetResources())
-      {
-        continue;
-      }
-
-      if(!GetConnector())
-      {
-        continue;
-      }
-
-      if(!GetEncoder())
-      {
-        continue;
-      }
+      return false;
+    }
 
-      if(!GetCrtc())
-      {
-        continue;
-      }
+    if(!GetConnector())
+    {
+      return false;
+    }
 
-      auto ret = drmSetClientCap(m_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
-      if (ret)
-      {
-        CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
-        return false;
-      }
+    if(!GetEncoder())
+    {
+      return false;
+    }
 
-      if(!GetPlanes())
-      {
-        continue;
-      }
+    if(!GetCrtc())
+    {
+      return false;
+    }
 
-      break;
+    if(!GetPlanes())
+    {
+      return false;
     }
   }
 
@@ -560,21 +576,30 @@ void CDRMUtils::DestroyDrm()
 {
   RestoreOriginalMode();
 
-  if (m_drm_resources)
-  {
-    drmModeFreeResources(m_drm_resources);
-    m_drm_resources = nullptr;
-  }
-
   drmDropMaster(m_fd);
   close(m_fd);
 
+  m_fd = -1;
+
+  drmModeFreeResources(m_drm_resources);
+  m_drm_resources = nullptr;
+
+  delete m_connector;
   m_connector = nullptr;
+
+  delete m_encoder;
   m_encoder = nullptr;
+
+  delete m_crtc;
   m_crtc = nullptr;
+
+  delete m_primary_plane;
   m_primary_plane = nullptr;
+
+  delete m_overlay_plane;
   m_overlay_plane = nullptr;
-  m_fd = -1;
+
+  drmModeFreeModeInfo(m_mode);
   m_mode = nullptr;
 }
 
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index ed6aaabffdb6..bb76b738b36c 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -69,8 +69,8 @@ class CDRMUtils
   virtual void FlipPage(struct gbm_bo *bo) {};
   virtual bool SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo) { return false; };
   virtual bool InitDrm();
+  virtual void DestroyDrm();
 
-  void DestroyDrm();
   bool GetModes(std::vector<RESOLUTION_INFO> &resolutions);
   bool SetMode(RESOLUTION_INFO res);
   void WaitVBlank();
@@ -83,8 +83,10 @@ class CDRMUtils
   struct plane *m_primary_plane = nullptr;
   struct plane *m_overlay_plane = nullptr;
   drmModeModeInfo *m_mode = nullptr;
+  drmModeAtomicReq *m_req = nullptr;
 
 protected:
+  bool OpenDrm();
   drm_fb * DrmFbGetFromBo(struct gbm_bo *bo);
 
 private:
@@ -94,11 +96,11 @@ class CDRMUtils
   bool GetCrtc();
   bool GetPlanes();
   bool GetPreferredMode();
-  int Open(const char* device);
   bool RestoreOriginalMode();
   static void DrmFbDestroyCallback(struct gbm_bo *bo, void *data);
 
   int m_crtc_index;
+
   drmModeResPtr m_drm_resources = nullptr;
   drmModeCrtcPtr m_orig_crtc = nullptr;
 };
diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index 2651d80202c7..b174bae3facf 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -28,10 +28,11 @@
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "../WinEventsLinux.h"
+#include "DRMAtomic.h"
 #include "DRMLegacy.h"
 
 CWinSystemGbm::CWinSystemGbm() :
-  m_DRM(new CDRMLegacy),
+  m_DRM(nullptr),
   m_GBM(new CGBMUtils),
   m_nativeDisplay(nullptr),
   m_nativeWindow(nullptr)
@@ -60,11 +61,21 @@ CWinSystemGbm::CWinSystemGbm() :
 
 bool CWinSystemGbm::InitWindowSystem()
 {
+  m_DRM = std::make_shared<CDRMAtomic>();
+
   if (!m_DRM->InitDrm())
   {
-    CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize Legacy DRM", __FUNCTION__);
+    CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize Atomic DRM", __FUNCTION__);
     m_DRM.reset();
-    return false;
+
+    m_DRM = std::make_shared<CDRMLegacy>();
+
+    if (!m_DRM->InitDrm())
+    {
+      CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize Legacy DRM", __FUNCTION__);
+      m_DRM.reset();
+      return false;
+    }
   }
 
   if (!m_GBM->CreateDevice(m_DRM->m_fd))
@@ -176,7 +187,13 @@ bool CWinSystemGbm::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     return false;
   }
 
-  struct gbm_bo *bo = m_GBM->LockFrontBuffer();
+  struct gbm_bo *bo = nullptr;
+
+  if (!m_DRM->m_req)
+  {
+    bo = m_GBM->LockFrontBuffer();
+  }
+
   auto result = m_DRM->SetVideoMode(res, bo);
   m_GBM->ReleaseBuffer();
 
