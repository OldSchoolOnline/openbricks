From 13e22cab99e47150411d41ed52c932f88afb9b7d Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 11 Nov 2017 23:59:07 +0100
Subject: [PATCH 03/13] VideoPlayer: add DRM PRIME video codec

---
 .../VideoPlayer/DVDCodecs/Video/CMakeLists.txt     |   5 +
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp      | 322 +++++++++++++++++++++
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.h        |  79 +++++
 3 files changed, 406 insertions(+)
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
index d8dcd15b4c..2cd5f1b7bb 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
@@ -51,4 +51,9 @@ if(CORE_SYSTEM_NAME STREQUAL android)
   list(APPEND HEADERS DVDVideoCodecAndroidMediaCodec.h)
 endif()
 
+if(CORE_PLATFORM_NAME STREQUAL gbm)
+  list(APPEND SOURCES DVDVideoCodecDRMPRIME.cpp)
+  list(APPEND HEADERS DVDVideoCodecDRMPRIME.h)
+endif()
+
 core_add_library(dvdvideocodecs)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
new file mode 100644
index 0000000000..0ee5ca47bc
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -0,0 +1,322 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDVideoCodecDRMPRIME.h"
+
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavutil/pixdesc.h"
+}
+
+//------------------------------------------------------------------------------
+// Video Buffers
+//------------------------------------------------------------------------------
+
+CVideoBufferDRMPRIME::CVideoBufferDRMPRIME(IVideoBufferPool& pool, int id)
+  : CVideoBuffer(id)
+{
+  m_pFrame = av_frame_alloc();
+}
+
+CVideoBufferDRMPRIME::~CVideoBufferDRMPRIME()
+{
+  Unref();
+  av_frame_free(&m_pFrame);
+}
+
+void CVideoBufferDRMPRIME::SetRef(AVFrame* frame)
+{
+  av_frame_move_ref(m_pFrame, frame);
+}
+
+void CVideoBufferDRMPRIME::Unref()
+{
+  av_frame_unref(m_pFrame);
+}
+
+//------------------------------------------------------------------------------
+
+class CVideoBufferPoolDRMPRIME
+  : public IVideoBufferPool
+{
+public:
+  ~CVideoBufferPoolDRMPRIME() override;
+  void Return(int id) override;
+  CVideoBuffer* Get() override;
+
+protected:
+  CCriticalSection m_critSection;
+  std::vector<CVideoBufferDRMPRIME*> m_all;
+  std::deque<int> m_used;
+  std::deque<int> m_free;
+};
+
+CVideoBufferPoolDRMPRIME::~CVideoBufferPoolDRMPRIME()
+{
+  for (auto buf : m_all)
+    delete buf;
+}
+
+CVideoBuffer* CVideoBufferPoolDRMPRIME::Get()
+{
+  CSingleLock lock(m_critSection);
+
+  CVideoBufferDRMPRIME* buf = nullptr;
+  if (!m_free.empty())
+  {
+    int idx = m_free.front();
+    m_free.pop_front();
+    m_used.push_back(idx);
+    buf = m_all[idx];
+  }
+  else
+  {
+    int id = m_all.size();
+    buf = new CVideoBufferDRMPRIME(*this, id);
+    m_all.push_back(buf);
+    m_used.push_back(id);
+  }
+
+  buf->Acquire(GetPtr());
+  return buf;
+}
+
+void CVideoBufferPoolDRMPRIME::Return(int id)
+{
+  CSingleLock lock(m_critSection);
+
+  m_all[id]->Unref();
+  auto it = m_used.begin();
+  while (it != m_used.end())
+  {
+    if (*it == id)
+    {
+      m_used.erase(it);
+      break;
+    }
+    else
+      ++it;
+  }
+  m_free.push_back(id);
+}
+
+//------------------------------------------------------------------------------
+// main class
+//------------------------------------------------------------------------------
+
+CDVDVideoCodecDRMPRIME::CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo)
+  : CDVDVideoCodec(processInfo)
+{
+  m_pFrame = av_frame_alloc();
+  m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIME>();
+}
+
+CDVDVideoCodecDRMPRIME::~CDVDVideoCodecDRMPRIME()
+{
+  av_frame_free(&m_pFrame);
+  avcodec_free_context(&m_pCodecContext);
+}
+
+CDVDVideoCodec* CDVDVideoCodecDRMPRIME::Create(CProcessInfo& processInfo)
+{
+  return new CDVDVideoCodecDRMPRIME(processInfo);
+}
+
+void CDVDVideoCodecDRMPRIME::Register()
+{
+  CDVDFactoryCodec::RegisterHWVideoCodec("drm_prime", CDVDVideoCodecDRMPRIME::Create);
+}
+
+AVCodec* CDVDVideoCodecDRMPRIME::FindDecoder(CDVDStreamInfo& hints)
+{
+  AVCodec* codec = nullptr;
+  while ((codec = av_codec_next(codec)))
+  {
+    if (av_codec_is_decoder(codec) && codec->id == hints.codec && codec->pix_fmts)
+    {
+      const AVPixelFormat* fmt = codec->pix_fmts;
+      while (*fmt != AV_PIX_FMT_NONE)
+      {
+        if (*fmt == AV_PIX_FMT_DRM_PRIME)
+          return codec;
+        fmt++;
+      }
+    }
+  }
+
+  return nullptr;
+}
+
+bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
+{
+  AVCodec* pCodec = FindDecoder(hints);
+  if (!pCodec)
+  {
+    CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::%s - unable to find decoder for codec %d", __FUNCTION__, hints.codec);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - using decoder %s", __FUNCTION__, pCodec->long_name ? pCodec->long_name : pCodec->name);
+
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
+  if (!m_pCodecContext)
+    return false;
+
+  m_pCodecContext->codec_tag = hints.codec_tag;
+  m_pCodecContext->coded_width = hints.width;
+  m_pCodecContext->coded_height = hints.height;
+  m_pCodecContext->bits_per_coded_sample = hints.bitsperpixel;
+
+  if (hints.extradata && hints.extrasize > 0)
+  {
+    m_pCodecContext->extradata_size = hints.extrasize;
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + AV_INPUT_BUFFER_PADDING_SIZE);
+    memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
+  }
+
+  if (avcodec_open2(m_pCodecContext, pCodec, nullptr) < 0)
+  {
+    CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - unable to open codec", __FUNCTION__);
+    avcodec_free_context(&m_pCodecContext);
+    return false;
+  }
+
+  const char* pixFmtName = av_get_pix_fmt_name(m_pCodecContext->pix_fmt);
+  m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
+  m_processInfo.SetVideoDimensions(hints.width, hints.height);
+  m_processInfo.SetVideoDeintMethod("none");
+
+  std::list<EINTERLACEMETHOD> deintMethods;
+  deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_NONE);
+  m_processInfo.UpdateDeinterlacingMethods(deintMethods);
+
+  if (pCodec->name)
+    m_name = std::string("ff-") + pCodec->name;
+  else
+    m_name = "ffmpeg";
+  m_name += "-drm_prime";
+
+  m_processInfo.SetVideoDecoderName(m_name, true);
+
+  return true;
+}
+
+bool CDVDVideoCodecDRMPRIME::AddData(const DemuxPacket& packet)
+{
+  if (!m_pCodecContext)
+    return true;
+
+  AVPacket avpkt;
+  av_init_packet(&avpkt);
+  avpkt.data = packet.pData;
+  avpkt.size = packet.iSize;
+  avpkt.dts = (packet.dts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.dts / DVD_TIME_BASE * AV_TIME_BASE);
+  avpkt.pts = (packet.pts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.pts / DVD_TIME_BASE * AV_TIME_BASE);
+  // TODO: avpkt.side_data = static_cast<AVPacketSideData*>(packet.pSideData);
+  // TODO: avpkt.side_data_elems = packet.iSideDataElems;
+
+  int ret = avcodec_send_packet(m_pCodecContext, &avpkt);
+  if (ret == AVERROR(EAGAIN))
+    return false;
+  else if (ret)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - send packet failed, ret:%d", __FUNCTION__, ret);
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecDRMPRIME::Reset()
+{
+  if (!m_pCodecContext)
+    return;
+
+  avcodec_flush_buffers(m_pCodecContext);
+  av_frame_unref(m_pFrame);
+  m_codecControlFlags = 0;
+}
+
+void CDVDVideoCodecDRMPRIME::Drain()
+{
+  AVPacket avpkt;
+  av_init_packet(&avpkt);
+  avpkt.data = nullptr;
+  avpkt.size = 0;
+  avcodec_send_packet(m_pCodecContext, &avpkt);
+}
+
+void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
+{
+  pVideoPicture->iWidth = m_pFrame->width;
+  pVideoPicture->iHeight = m_pFrame->height;
+
+  // TODO: use correct values
+  pVideoPicture->iDisplayWidth = m_pFrame->width;
+  pVideoPicture->iDisplayHeight = m_pFrame->height;
+
+  pVideoPicture->color_range = m_pFrame->color_range;
+  pVideoPicture->color_primaries = m_pFrame->color_primaries;
+  pVideoPicture->color_transfer = m_pFrame->color_trc;
+  pVideoPicture->color_matrix = m_pFrame->colorspace;
+
+  pVideoPicture->iFlags = 0;
+  pVideoPicture->iFlags |= m_pFrame->interlaced_frame ? DVP_FLAG_INTERLACED : 0;
+  pVideoPicture->iFlags |= m_pFrame->top_field_first ? DVP_FLAG_TOP_FIELD_FIRST: 0;
+  pVideoPicture->iFlags |= m_pFrame->data[0] ? 0 : DVP_FLAG_DROPPED;
+
+  pVideoPicture->pts = (m_pFrame->pts == AV_NOPTS_VALUE) ? DVD_NOPTS_VALUE : (double)m_pFrame->pts * DVD_TIME_BASE / AV_TIME_BASE;
+  pVideoPicture->dts = DVD_NOPTS_VALUE;
+
+  // TODO: fix pts if picture->pts is DVD_NOPTS_VALUE ?
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideoPicture)
+{
+  if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
+    Drain();
+
+  int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
+  if (ret == AVERROR(EAGAIN))
+    return VC_BUFFER;
+  else if (ret == AVERROR_EOF)
+    return VC_EOF;
+  else if (ret)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - receive frame failed, ret:%d", __FUNCTION__, ret);
+    return VC_ERROR;
+  }
+
+  if (pVideoPicture->videoBuffer)
+    pVideoPicture->videoBuffer->Release();
+  pVideoPicture->videoBuffer = nullptr;
+
+  SetPictureParams(pVideoPicture);
+
+  CVideoBufferDRMPRIME* buffer = dynamic_cast<CVideoBufferDRMPRIME*>(m_videoBufferPool->Get());
+  buffer->SetRef(m_pFrame);
+  pVideoPicture->videoBuffer = buffer;
+
+  return VC_PICTURE;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
new file mode 100644
index 0000000000..12c0f6d505
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
@@ -0,0 +1,79 @@
+/*
+ *      Copyright (C) 2017 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include <memory>
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/Process/VideoBuffer.h"
+
+extern "C" {
+#include "libavutil/frame.h"
+#include "libavutil/hwcontext_drm.h"
+}
+
+class CVideoBufferPoolDRMPRIME;
+
+class CVideoBufferDRMPRIME
+  : public CVideoBuffer
+{
+public:
+  CVideoBufferDRMPRIME(IVideoBufferPool& pool, int id);
+  virtual ~CVideoBufferDRMPRIME();
+  void SetRef(AVFrame* frame);
+  void Unref();
+
+  AVDRMFrameDescriptor* GetDescriptor() const { return reinterpret_cast<AVDRMFrameDescriptor*>(m_pFrame->data[0]); }
+  uint32_t GetWidth() const { return m_pFrame->width; }
+  uint32_t GetHeight() const { return m_pFrame->height; }
+protected:
+  AVFrame* m_pFrame = nullptr;
+};
+
+class CDVDVideoCodecDRMPRIME
+  : public CDVDVideoCodec
+{
+public:
+  explicit CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo);
+  ~CDVDVideoCodecDRMPRIME() override;
+
+  static CDVDVideoCodec* Create(CProcessInfo& processInfo);
+  static void Register();
+
+  bool Open(CDVDStreamInfo& hints, CDVDCodecOptions& options) override;
+  bool AddData(const DemuxPacket& packet) override;
+  void Reset() override;
+  CDVDVideoCodec::VCReturn GetPicture(VideoPicture* pVideoPicture) override;
+  const char* GetName() override { return m_name.c_str(); };
+  unsigned GetAllowedReferences() override { return 4; };
+  void SetCodecControl(int flags) override { m_codecControlFlags = flags; };
+
+protected:
+  virtual AVCodec* FindDecoder(CDVDStreamInfo& hints);
+  virtual void Drain();
+  virtual void SetPictureParams(VideoPicture* pVideoPicture);
+
+  std::string m_name;
+  int m_codecControlFlags = 0;
+  AVCodecContext* m_pCodecContext = nullptr;
+  AVFrame* m_pFrame = nullptr;
+  std::shared_ptr<CVideoBufferPoolDRMPRIME> m_videoBufferPool;
+};
-- 
2.11.0

