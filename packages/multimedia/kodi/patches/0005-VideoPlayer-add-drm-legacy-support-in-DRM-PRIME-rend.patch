From f926a8edaf0287055a5b0c75bc79f7d5db345bc4 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 11 Nov 2017 23:59:07 +0100
Subject: [PATCH 05/13] VideoPlayer: add drm legacy support in DRM PRIME
 renderer

---
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp      | 19 +++++++
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.h        |  3 ++
 .../HwDecRender/RendererDRMPRIME.cpp               | 62 +++++++++++++++++++++-
 xbmc/windowing/gbm/DRMUtils.cpp                    |  5 ++
 xbmc/windowing/gbm/DRMUtils.h                      |  1 +
 5 files changed, 89 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
index 0ee5ca47bc..a8be781d31 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -23,6 +23,7 @@
 #include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
 #include "threads/SingleLock.h"
 #include "utils/log.h"
+#include "windowing/gbm/DRMUtils.h"
 
 extern "C" {
 #include "libavcodec/avcodec.h"
@@ -52,6 +53,24 @@ void CVideoBufferDRMPRIME::SetRef(AVFrame* frame)
 
 void CVideoBufferDRMPRIME::Unref()
 {
+  struct drm* drm = CDRMUtils::GetDrm();
+
+  if (m_fb_id)
+  {
+    drmModeRmFB(drm->fd, m_fb_id);
+    m_fb_id = 0;
+  }
+
+  for (int i = 0; i < AV_DRM_MAX_PLANES; i++)
+  {
+    if (m_handles[i])
+    {
+      struct drm_gem_close gem_close = { .handle = m_handles[i] };
+      drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
+      m_handles[i] = 0;
+    }
+  }
+
   av_frame_unref(m_pFrame);
 }
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
index 12c0f6d505..3a94bd94e1 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
@@ -41,6 +41,9 @@ public:
   void SetRef(AVFrame* frame);
   void Unref();
 
+  uint32_t m_fb_id = 0;
+  uint32_t m_handles[AV_DRM_MAX_PLANES] = {0};
+
   AVDRMFrameDescriptor* GetDescriptor() const { return reinterpret_cast<AVDRMFrameDescriptor*>(m_pFrame->data[0]); }
   uint32_t GetWidth() const { return m_pFrame->width; }
   uint32_t GetHeight() const { return m_pFrame->height; }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
index 1de70b8e6c..5ea349c037 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -23,6 +23,7 @@
 #include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
 #include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
 #include "utils/log.h"
+#include "windowing/gbm/DRMUtils.h"
 
 CRendererDRMPRIME::CRendererDRMPRIME()
 {
@@ -161,5 +162,64 @@ bool CRendererDRMPRIME::Supports(ESCALINGMETHOD method)
 
 void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
 {
-  // TODO: implement
+  AVDRMFrameDescriptor* descriptor = buffer->GetDescriptor();
+  if (descriptor && descriptor->nb_layers)
+  {
+    uint32_t handles[4] = {0}, pitches[4] = {0}, offsets[4] = {0};
+    struct drm* drm = CDRMUtils::GetDrm();
+    int ret;
+
+    // convert Prime FD to GEM handle
+    for (int object = 0; object < descriptor->nb_objects; object++)
+    {
+      ret = drmPrimeFDToHandle(drm->fd, descriptor->objects[object].fd, &buffer->m_handles[object]);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to retrieve the GEM handle from prime fd %d, ret = %d", __FUNCTION__, descriptor->objects[object].fd, ret);
+        return;
+      }
+    }
+
+    AVDRMLayerDescriptor* layer = &descriptor->layers[0];
+
+    for (int plane = 0; plane < layer->nb_planes; plane++)
+    {
+      uint32_t handle = buffer->m_handles[layer->planes[plane].object_index];
+      if (handle && layer->planes[plane].pitch)
+      {
+        handles[plane] = handle;
+        pitches[plane] = layer->planes[plane].pitch;
+        offsets[plane] = layer->planes[plane].offset;
+      }
+    }
+
+    // add the video frame FB
+    ret = drmModeAddFB2(drm->fd, buffer->GetWidth(), buffer->GetHeight(), layer->format, handles, pitches, offsets, &buffer->m_fb_id, 0);
+    if (ret < 0)
+    {
+      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to add drm layer %d, ret = %d", __FUNCTION__, buffer->m_fb_id, ret);
+      return;
+    }
+
+    int32_t crtc_x = (int32_t)m_destRect.x1;
+    int32_t crtc_y = (int32_t)m_destRect.y1;
+    uint32_t crtc_w = (uint32_t)m_destRect.Width();
+    uint32_t crtc_h = (uint32_t)m_destRect.Height();
+    uint32_t src_x = 0;
+    uint32_t src_y = 0;
+    uint32_t src_w = buffer->GetWidth() << 16;
+    uint32_t src_h = buffer->GetHeight() << 16;
+
+    // TODO: use atomic or legacy api
+
+    // show the video frame FB on the video plane
+    ret = drmModeSetPlane(drm->fd, drm->video_plane_id, drm->crtc_id, buffer->m_fb_id, 0,
+                          crtc_x, crtc_y, crtc_w, crtc_h,
+                          src_x, src_y, src_w, src_h);
+    if (ret < 0)
+    {
+      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->video_plane_id, buffer->m_fb_id, ret);
+      return;
+    }
+  }
 }
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index bcf9a49350..bff6941f7b 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -42,6 +42,11 @@ static drmModeConnectorPtr m_drm_connector = nullptr;
 static drmModeEncoderPtr m_drm_encoder = nullptr;
 static drmModeCrtcPtr m_orig_crtc = nullptr;
 
+struct drm *CDRMUtils::GetDrm()
+{
+  return m_drm;
+}
+
 bool CDRMUtils::SetMode(RESOLUTION_INFO res)
 {
   m_drm->mode = &m_drm_connector->modes[atoi(res.strId.c_str())];
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index bef303ab5c..e4967feb01 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -68,6 +68,7 @@ public:
   static void DestroyDrm();
   static bool GetModes(std::vector<RESOLUTION_INFO> &resolutions);
   static bool SetMode(RESOLUTION_INFO res);
+  static struct drm *GetDrm();
 
 protected:
   static drm_fb * DrmFbGetFromBo(struct gbm_bo *bo);
-- 
2.11.0

